---
title: "14.우선순위큐"
firstDate: "2021-03-31"
lastDate: "2021-03-31"
---

## 개념

은행업무를 보기위해 줄서는것을 큐라고하면,
갑자기 VIP고객이 왔을때, 그 상황을 우선순위 큐 라고 볼수있다
구현을 하기 앞서, heap 자료구조를 이용할건데,
heap 이란녀석을 먼저 알아보자

## 힙(heap) 구조

가장큰(또는 작은) 순서를 유지하는 자료구조이다
추가,삭제를 수행시, 정렬이 수행된다
가장큰(또는작은) 항목을 구하는 목적으로, 완전 오름차순, 내림차순정렬이 아니다.

## 힙 구현

```Python
class Heapify(object):
    def __init__(self, data=None):
        self.data = data or []
        for i in range(len(data) // 2, -1, -1):
            self.__max_heapify__(i)

    def __repr__(self):
        return repr(self.data)

    def parent(self, i):
        if i & 1:
            return i >> 1
        else:
            return (i >> 1) - 1

    def left_child(self, i):
        return (i << 1) + 1

    def right_child(self, i):
        return (i << 1) + 2

    def __max_heapify__(self, i):
        largest = i  # 현재노드
        left = self.left_child(i)
        right = self.right_child(i)
        n = len(self.data)
        # 왼쪽자식
        largest = (left < n and self.data[left] > self.data[i]) and left or i
        # 오른쪽 자식
        largest = (right < n and self.data[right] > self.data[largest]) and right or largest

        # 현재 노드가 자식들보다 크다면 skip, 자식이 크다면 swap
        if i is not largest:
            self.data[i], self.data[largest] = self.data[largest], self.data[i]
            self.__max_heapify__(largest)

    def extract_max(self):
        n = len(self.data)
        max_element = self.data[0]
        # 첫번째 노드에 마지막 노드를 삽입
        self.data[0] = self.data[n - 1]
        self.data = self.data[: n - 1]
        self.__max_heapify__(0)
        return max_element

    def insert(self, item):
        i = len(self.data)
        self.data.append(item)
        while (i != 0) and item > self.data[self.parent(i)]:
            print(self.data)
            self.data[i] = self.data[self.parent(i)]
            i = self.parent(i)
        self.data[i] = item


l1 = [3, 2, 5, 1, 7, 8, 2]
h = Heapify(l1)
print(h.extract_max())
```

## heapq 모듈

heap자료구조를 알아보았으니, 라이브러리로 제공하는 heapq모듈을 알아보자
heapq 모듈은 기본적으로 minHeap 이다
maxHeap으로 할땐 priority를 음수로 반전해주면 된다

```Python
import heapq

l1 = [4, 6, 8, 1]
heapq.heapify(l1)
print(l1)  # [1, 4, 8, 6]

h = []
heapq.heappush(h, (4, "사부"))
print(h)  # [(4, '사부')]
heapq.heappush(h, (6, "육개장"))
print(h)  # [(4, '사부'), (6, '육개장')]
heapq.heappush(h, (8, "팔공산"))
print(h)  # [(4, '사부'), (6, '육개장'), (8, '팔공산')]
heapq.heappush(h, (1, "일침"))
print(h)  # [(1, '일침'), (4, '사부'), (8, '팔공산'), (6, '육개장')]


heapq.heappop(h) # 제일 작은것을 제거하고,반환
print(h)  # [(4, '사부'), (6, '육개장'), (8, '팔공산')]

```

## 우선순위 큐 구현

```Python
import heapq


class PriorityQueue(object):
    def __init__(self):
        self._queue = []

    def push(self, priority, data):
        heapq.heappush(self._queue, (-priority, data))

    def pop(self):
        return heapq.heappop(self._queue)[-1]


q = PriorityQueue()
q.push(4, "사사사")
q.push(8, dict({"a": 1}))
q.push(6, [1, 2, 3, 4])
q.push(1, 100)
print(q.pop())
print(q.pop())
print(q.pop())
print(q.pop())
```
